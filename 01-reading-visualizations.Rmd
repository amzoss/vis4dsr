\mainmatter

```{r ch1-setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Overview of common visualizations and how to read them {#reading-visualizations}

```{r, include=FALSE}

source('data/inclusiveness_index/load_inclusiveness_index.R')

inclusive.levels <- c("High", "Medium-High", "Medium", "Medium-Low", "Low", "No data")

inclusiveness_index <- inclusiveness_index %>%
    mutate(Index.categories.2020 = Index.categories.2020 %>%
           as_factor() %>%
           fct_relevel(inclusive.levels))

library(RColorBrewer)

inclusive.colors <- rev(c("#BBBBBB", brewer.pal(7, "GnBu")[3:7]))
inclusive.colors <- setNames(inclusive.colors, inclusive.levels)

```

```{r, eval=FALSE}

inclusiveness_index_annual %>%
  drop_na(Inclusiveness.index) %>%
  ggplot(aes(x = Year, y = Inclusiveness.index, color = Continent)) +
    geom_jitter()

```

This book will cover how to create a variety of visualizations using R. One of the
first things you should do to improve your skills creating visualizations is to
become familiar with the kinds of visualizations that are possible and the different
features of each. 

Effective visualization design relies on a solid understanding
of how data properties, visualization types, and audience characteristics interact
to help people make sense of a visualization.  In this chapter, we'll look at
a series of common visualization types, and we'll break down how each is meant to
be read. Understanding these basic visualization types will create a solid foundation for
communicating your data science work to a broad audience.

## Visualization components

As we discuss different visualizations, we will also be talking about different
components within the visualizations. In figure \@ref(fig:vis-components) below, 
the major components of the visualization are labeled: the main title, the subtitle,
the x axis title, the y axis title, the panel, the horizontal and vertical gridlines,
and the axis labels and tick marks for both axes. Almost all of the visualizations we cover 
in this book will use these basic components.

```{r vis-components, fig.cap='Visualization components, labeled.'}

tibble(x = c(0:4), y=c(0:4)) %>%
  ggplot(aes(x=x,y=y)) +
  labs(title = "Main title",
       subtitle = "Subtitle",
       x = "x axis title", 
       y = "y axis title") +
  coord_cartesian(xlim=c(0,4), ylim=c(0,4)) +
  annotate("text", x = 0, y = 3.7, label = "panel", size = 5.5, hjust=0) + 
  annotate("text", x = .9, y = 3.1, label = "horizontal gridlines", size = 4, hjust=0) +
  annotate("text", x = 2.45, y = 2.2, label = "vertical gridlines", size = 4, hjust=0, angle=90) + 
  annotate("text", x = .25, y = .75, label = "y axis labels and tick marks", size = 4, hjust=0) +
  annotate("segment", x = .2, xend = -.1, y = .745, yend = 1, 
           arrow = arrow(type = "closed", length = unit(.07, "inches"))) +
  annotate("segment", x = .2, xend = -.1, y = .745, yend = 0, 
           arrow = arrow(type = "closed", length = unit(.07, "inches"))) +
  annotate("text", x = 3.5, y = .75, label = "x axis labels and tick marks", size = 4) +
  annotate("segment", x = 3.5, xend = 3, y = .6, yend = 0, 
           arrow = arrow(type = "closed", length = unit(.07, "inches"))) +
  annotate("segment", x = 3.5, xend = 4, y = .6, yend = 0, 
           arrow = arrow(type = "closed", length = unit(.07, "inches"))) + 
  theme_grey(base_size=13) 

```

In this set of basic visualization components, we see two components labeled as an axis. 
These axes are called the x and y axes, and they always appear in these positions: 
the x axis always goes left to right, and the y axis always goes up and down.

## Bar Chart

The bar chart is possibly the most common type of visualization. In this type
of visualization, the basic shape being used to represent data values is a rectangle. 
In a traditional bar chart, each rectangle (or bar) has exactly the same width, 
and the height of the bar is representative of some data value. To create a simple
bar chart, the data set should have one column that contains textual (or categorical)
data and one column that contains numerical data. A common way to create these two columns
is to start with one categorical data column and count the number of records for each 
category to create the numerical column.

```{r sample-bar, fig.cap='A sample bar chart.'}

ggplot(
  inclusiveness_index %>% 
    mutate(Continent = Continent %>% as_factor() %>% fct_infreq()),
  mapping = aes(x = Continent)) +
  geom_bar() +
  labs(y="Number of Records")

```

In the sample bar chart above, the categorical variable is displayed on the 
x axis and the numerical variable is displayed on the y axis. This results in a 
classic style of bar chart where each bar has the same width and the heights are 
proportionate to a data value. Each bar has a starting value of zero on the y axis. 
Each bar travels upward from zero and stops at the correct data value. 

When reading this visualization, we are comparing the lengths of bars in order to
understand patterns within the numerical data values from our data set. The power 
of the bar chart lies in how precisely we can detect differences in the
end points of the bars. This is something that people naturally do quite well 
when all of the bars start at the same lowest point, or baseline. 

Bar charts are especially effective if the bars that have small differences in 
lengths appear close to each other. In the above chart, this is accomplished by 
arranging the bars so they appear with the highest data values on the left and 
the lowest data values on the right.

```{r sample-bar-neg, fig.cap='A sample bar chart with both positive and negative values.'}

inclusiveness_index %>% 
  drop_na(Inclusiveness.index.2020) %>%
  group_by(Continent) %>%
  summarize(`Mean Inclusiveness Index` = mean(Inclusiveness.index.2020)) %>%
  mutate(Continent = Continent %>% as_factor() %>% fct_reorder(`Mean Inclusiveness Index`, .desc = TRUE)) %>% 
ggplot(mapping = aes(x = Continent, y = `Mean Inclusiveness Index`)) +
  geom_col()

```

Here is another example of a bar chart where the data values include both positive
and negative values. For data values that are negative, the bar travels downward 
from zero and stops at the correct data value. The x axis title and labels appear 
at the bottom of the panel, below the lowest data values.

For stylistic reasons, bar charts may also appear with the bars oriented horizontally
instead of vertically. In that case, each bar will have the same height, and the widths
of the bars will vary based on the data values. The text (or categorical) axis will then
be the y axis, and the numerical axis will be the x axis.

```{r sample-bar-horizontal, fig.cap='A sample bar chart, with the bars oriented horizonally.'}

inclusiveness_index %>% 
  drop_na(Inclusiveness.index.2020) %>%
  group_by(Continent) %>%
  summarize(`Mean Inclusiveness Index` = mean(Inclusiveness.index.2020)) %>%
  mutate(Continent = Continent %>% as_factor() %>% fct_reorder(`Mean Inclusiveness Index`)) %>% 
ggplot(mapping = aes(y = Continent, x = `Mean Inclusiveness Index`)) +
  geom_col()

```

### Variations

The following charts are variations on a bar chart. They either incorporate
additional variables, change the basic shape of the chart, or both.

#### Lollipop plot

One quick variation of the bar chart is called the lollipop plot In a lollipop plot,
the bars are replace by a long line with a circle at the end, creating something
that looks like a lollipop. Apart from the different shapes used, the lollipop plot 
works just like a bar chart. The circles draw attention to the data value, but the
lines extending to the axis reinforce the length comparisons.

```{r sample-lollipop, fig.cap='A sample lollipop plot.'}

ggplot(
  inclusiveness_index %>% 
    count(Continent) %>%
    mutate(Continent = Continent %>% as_factor() %>% fct_reorder(n, .desc = TRUE)),
  mapping = aes(x = Continent, y=n)) +
  geom_col(width=.03) +
  geom_point(size=4) +
  labs(y="Number of Records")

```

```{r sample-lolli-neg, fig.cap='A sample lollipop plot with both positive and negative values.'}

inclusiveness_index %>% 
  drop_na(Inclusiveness.index.2020) %>%
  group_by(Continent) %>%
  summarize(`Mean Inclusiveness Index` = mean(Inclusiveness.index.2020)) %>%
  mutate(Continent = Continent %>% as_factor() %>% fct_reorder(`Mean Inclusiveness Index`, .desc = TRUE)) %>% 
ggplot(mapping = aes(x = Continent, y = `Mean Inclusiveness Index`)) +
  geom_col(width=.03) +
  geom_point(size=4) 

```

#### Bar charts with color

A simple bar chart includes one categorical variable and one numerical variable.
Sometimes, however, it is useful to explore the patterns in relation to a second
categorical variable. Adding another categorical variable to a bar chart usually
means using color to represent the extra variable.

With a stacked bar chart, the additional variable is used to segment the bars into
separate, colored regions. In this example, the bar for each continent is subdivided
into groups of countries based on their values for Inclusive Index.


```{r sample-stacked-bar, fig.cap='A sample stacked bar chart.'}

ggplot(
  inclusiveness_index %>% 
    count(Continent, Index.categories.2020) %>%
    mutate(Continent = Continent %>% as_factor() %>% fct_reorder(n, .fun = sum, .desc = TRUE)),
  mapping = aes(x = Continent, y = n, fill = Index.categories.2020)) +
  geom_col() +
  labs(y="Number of Records", fill="Inclusiveness Index") +
  scale_fill_manual(values=inclusive.colors)

```

With this stacked bar chart, you can still see the total number of records for each Continent,
but what happens when you try to compare the different segments inside the
bar chart? Starting at the bottom, it seems to work out okay. All of the bars
for the "No data" category start at the same baseline (the x axis), and we can
read these segments like a normal bar chart. But what happens with the "Low" segments
right above them? And the "Medium-Low" segments above those? Every time we have
a group of segments that aren't lined up with each other, we have to try to guess
how tall the bar is in comparison to the other bars in the group. The farther
apart the segments are, the harder it is to make that comparison.

Another variation of the stacked bar chart is the "filled" stacked bar chart.
Instead of using the raw counts to determine the lengths of the bars, in the
filled stacked bar chart, the full bars are all stretched to have the same height,
and each segment becomes the percentage of the records in each bar. (Notice how
the y axis changes from "Number" to "Percentage.") This is useful if the percentages 
matter more than the raw counts, but it doesn't fix any of the concerns with 
comparing different segments without a common baseline.

```{r sample-filled-stacked-bar, fig.cap='A sample filled stacked bar chart.'}

ggplot(
  inclusiveness_index %>% 
    count(Continent, Index.categories.2020) %>%
    mutate(Continent = Continent %>% as_factor() %>% fct_reorder(n, .fun = sum, .desc = TRUE)),
  mapping = aes(x = Continent, y = n, fill = Index.categories.2020)) +
  geom_col(position = "fill") +
  labs(y="Percentage of Records", fill="Inclusiveness Index") +
  scale_fill_manual(values=inclusive.colors)

```

An alternative to the stacked bar chart is called the grouped bar chart. In the
grouped bar chart, every segment starts from the x axis. Each continent forms a
group of bars, and each option of the Inclusiveness Index is a separate bar.

```{r sample-grouped-bar, fig.cap='A sample grouped bar chart.'}

ggplot(
  inclusiveness_index,
  mapping = aes(x = Continent, fill = Index.categories.2020)) +
  geom_bar(position = position_dodge2(preserve="single")) +
  labs(y="Number of Records", fill="Inclusiveness Index") +
  scale_fill_manual(values=inclusive.colors)

```

#### Dumbbell plot

Stacked and grouped bar charts show some of the limitations of bar charts for
making complex comparisons. The rectangles in the bar chart take up a large amount
of space. Think back to the lollipop plot, where it's the circles that directly
represent the data value. Converting bars to something like circles opens up the
ability to make more direct comparisons.

For example, let's say we want to compare two continents more directly: Asia and Europe.

```{r sample-grouped-bar-2-cont, fig.cap='A grouped bar chart focusing on two continents.'}

ggplot(
  inclusiveness_index %>% dplyr::filter(Continent %in% c("Asia", "Europe")),
  mapping = aes(x = Continent, fill = Index.categories.2020)) +
  geom_bar(position = position_dodge2(preserve="single")) +
  labs(y="Number of Records", fill="Inclusiveness Index") +
  scale_fill_manual(values=inclusive.colors)

```

This chart groups all of the segments by continent, which makes it easy to compare
different Index categories within a single continent. What if we want to bring more
attention to the difference between continents for each category? We could always
switch which category is the primary division on the x axis and which is 
represented by color.

```{r sample-grouped-bar-2-cont-switched, fig.cap='The same grouped bar chart with a different arrangement of the categorical variables.'}

ggplot(
  inclusiveness_index %>% dplyr::filter(Continent %in% c("Asia", "Europe")),
  mapping = aes(x = Index.categories.2020, fill = Continent)) +
  geom_bar(position = position_dodge2(preserve="single")) +
  labs(y="Number of Records", x="Inclusiveness Index") +
  scale_fill_manual(values=c(as.character(inclusive.colors["Medium-Low"]), 
                             as.character(inclusive.colors["High"])))

```

This improves our ability to compare the continents directly because the bars are
directly next to each other. The amount of space the bars take up is still pretty
large, though. If we combine this chart with something like a lollipop plot, we
get one last variation: a dumbbell plot.

With a dumbbell plot, we use a circle to represent the data values, just like the
lollipop. Instead of having a line that extends all the way to the axis, though,
we use a line to connect the two dots in each category of Inclusiveness Index.


```{r sample-dumbbell, fig.cap='A dumbbell plot comparing two continents.'}

ggplot(
  inclusiveness_index %>% dplyr::filter(Continent %in% c("Asia", "Europe")) %>%
    count(Continent, Index.categories.2020),
  mapping = aes(x = Index.categories.2020, y=n)) +
  geom_line(aes(group=Index.categories.2020), color="#555555", size=1) +
  geom_point(aes(color = Continent), size=6) +
  labs(y="Number of Records", x="Inclusiveness Index") +
  scale_color_manual(values=c(as.character(inclusive.colors["Medium-Low"]), 
                             as.character(inclusive.colors["High"])))

```

With a dumbbell plot, there are three main trends we can explore in the chart. We
can focus on the green circles to see the pattern in the Asia data values. We can
focus on the blue circles to see the pattern in the Europe data values. Finally, 
we can focus on the lengths of the lines connecting the circles to compare the 
continents at each level of the Inclusiveness Index. This chart time is an efficient
way to compare these data values, but remember that it can be difficult to compare
the lengths of shapes when they don't have the same baseline.

## Scatter Plot


### Variations

#### Scatter plot with color 

#### Bubble chart

#### Countour plot

```{r}

inclusiveness_index %>%
  drop_na(Z.score.Religion, Inclusiveness.index.2020) %>%
  ggplot(aes(x = Z.score.Religion, 
             y = Inclusiveness.index.2020)) +
    geom_point()

```


## Line Chart

line chart / area chart

```{r}

inclusiveness_index_annual %>%
  group_by(Year, Continent) %>%
  summarise(mean_incl_ind = mean(Inclusiveness.index, na.rm = TRUE)) %>%
  dplyr::filter(Continent == "Europe") %>%
ggplot(aes(x = Year, 
           y = mean_incl_ind)) +
  geom_line()

inclusiveness_index_annual %>%
  group_by(Year, Continent) %>%
  summarise(mean_incl_ind = mean(Inclusiveness.index, na.rm = TRUE)) %>%
  ggplot(aes(x = Year, 
             y = mean_incl_ind,
             color = Continent)) +
    geom_line()

```

## Pie Chart

pie chart / donut chart

```{r}

# library(RColorBrewer)
# brewer.pal(5, "Blues")

inclusiveness_index %>%
  #dplyr::filter(Continent == "Americas") %>%
  ggplot(aes(y = "", fill = Index.categories.2020)) +
    geom_bar(position=position_fill()) +
    coord_polar(direction = -1) +
    #scale_fill_brewer(type="seq", palette = 1, direction = -1) +
    scale_fill_manual(values = c("#08519C","#3182BD","#6BAED6","#9ECAE1","#C6DBEF","#EEEEEE")) +
    theme_void() +
    facet_wrap(vars(Continent))

```


## Heat Map

heat map / matrix / circles with color and size

```{r}

inclusiveness_index %>%
  pivot_longer(cols = c(Inclusiveness.index.2020, starts_with("Z")), 
               names_to = "index_name",
               values_to = "index_values",
               values_drop_na = TRUE) %>%
  group_by(Index.categories.2020, index_name) %>%
  summarise(mean_incl_ind = mean(index_values)) %>%
  mutate(index_name = index_name %>%
           as_factor() %>%
           fct_relevel(c("Z.score.General.Population", "Z.score.Race", "Z.score.Gender", 
                         "Z.score.Sexual.Orientation", "Z.score.Religion", 
                         "Z.score.Disability", "Inclusiveness.index.2020")) %>%
           fct_rev()) %>%
  #View() %>%
  ggplot(aes(y = index_name, x = Index.categories.2020, fill = mean_incl_ind)) +
    geom_tile() +
    scale_fill_distiller(type="div", palette = 3, 
                         limits=c(-1.2,1.2), 
                         direction = -1) +
  theme_bw()

```


## Histogram

histogram / density

```{r}

inclusiveness_index %>%
  drop_na(Inclusiveness.index.2020) %>%
  ggplot(aes(x = Inclusiveness.index.2020)) +
    geom_histogram()

```


## Box Plot

box plot / violin plot / bee swarm

```{r}

ggplot(inclusiveness_index, 
       aes(group = Z.score.Disability, 
           y = Inclusiveness.index.2020)) +
  geom_boxplot()

```


## Maps

choropleth / proportional symbol map

```{r}

map_incl_ind <- inclusiveness_index %>%
  mutate(Country = case_when(
    Country == "Antigua and Barbuda" ~ "Antigua",
    Country == "Bonaire, Saint Eustatius and Saba" ~ "Bonaire",
    Country == "Cote d'Ivoire" ~ "Ivory Coast",
    Country == "East Timor" ~ "Timor-Leste",
    Country == "Palestina" ~ "Palestine",
    Country == "Saint Kitts and Nevis" ~ "Saint Kitts",
    Country == "Saint Vincent and the Grenadines" ~ "Saint Vincent",
    Country == "Saint-Barthalemy" ~ "Saint Barthelemy",
    Country == "Saint-Martin" ~ "Saint Martin",
    Country == "Trinidad and Tobago" ~ "Trinidad",
    Country == "United Kingdom" ~ "UK",
    Country == "United States" ~ "USA",
    Country == "Vatican City" ~ "Vatican",
    TRUE ~ Country
  )) %>%
  bind_rows(
    inclusiveness_index %>% dplyr::filter(
      Country %in% c("Antigua and Barbuda", "Bonaire, Saint Eustatius and Saba",
                     "Saint Kitts and Nevis", "Saint Vincent and the Grenadines",
                     "Trinidad and Tobago")
    ) %>% mutate(Country = case_when(
      Country == "Antigua and Barbuda" ~ "Barbuda",
      Country == "Bonaire, Saint Eustatius and Saba" ~ "Sint Eustatius",
      Country == "Saint Kitts and Nevis" ~ "Nevis",
      Country == "Saint Vincent and the Grenadines" ~ "Grenadines",
      Country == "Trinidad and Tobago" ~ "Tobago",
      TRUE ~ Country
      )
    ),
    inclusiveness_index %>% dplyr::filter(
      Country %in% c("Bonaire, Saint Eustatius and Saba")
    ) %>% mutate(Country = case_when(
      Country == "Bonaire, Saint Eustatius and Saba" ~ "Saba",
      TRUE ~ Country
      )
    )
  ) 

map_incl_ind %>%
  left_join(map_data("world2"), by = c("Country" = "region")) %>%
  ggplot() + 
    geom_polygon(aes(x = long,
                     y = lat,
                     group=group,
                     fill=Inclusiveness.index.2020)) +
    coord_map() +
    scale_fill_distiller(type="div", palette = 3, 
                         limits=c(-1.2,1.2), 
                         direction = -1)

map_incl_ind %>%
  drop_na(Inclusiveness.index.2020) %>%
  left_join(
    map_data("world2") %>% 
      group_by(region) %>%
      summarise(x = mean(long),
                y = mean(lat)), 
    by = c("Country" = "region")) %>%
  ggplot() +
    geom_polygon(
      data = map_data("world2"),
      aes(x = long,
          y = lat,
          group=group),
      fill = "grey50",
      color = "black") +
    coord_map() +
    geom_point(aes(x = x, y = y, 
                   fill = Index.categories.2020, 
                   size = Inclusiveness.index.2020),
               shape = 21,
               alpha = .75) +
    scale_fill_brewer(palette = "YlGnBu", direction = -1)
  
 

```

## Movies

```{r}

library(ggplot2movies) # add to index if you use this instead

# Movies were selected for inclusion if they had a known length and had 
# been rated by at least one imdb user.
movies <- movies

```

```{r}

movies %>% 
  pivot_longer(cols = c(Action, Animation, Comedy, Drama, Documentary, Romance, Short), names_to = "genre") %>%
  mutate(value = as.logical(value)) %>%
  dplyr::filter(value) %>%
  mutate(genre = genre %>%
           as_factor() %>%
           fct_infreq) %>%
  ggplot(aes(x=genre)) +
    geom_bar()
```

```{r}

ggplot(movies, aes(budget, rating)) +
  geom_point()

```

```{r}

movies %>%
  group_by(year) %>%
  summarise(mean_budget = mean(budget, na.rm=T)) %>%
  ggplot(aes(x=year, y=mean_budget)) +
    geom_line()

```

```{r}

movies %>% 
  pivot_longer(cols = c(Action, Animation, Comedy, Drama, Documentary, Romance, Short), names_to = "genre") %>%
  mutate(value = as.logical(value)) %>%
  dplyr::filter(value) %>%
  mutate(genre = genre %>%
           as_factor() %>%
           fct_infreq) %>%
  ggplot(aes(y="", fill=genre)) +
    geom_bar(position = position_fill()) +
    coord_polar(direction = -1)

```

```{r}

movies %>% 
  pivot_longer(cols = c(Action, Animation, Comedy, Drama, Documentary, Romance, Short), names_to = "genre") %>%
  mutate(value = as.logical(value)) %>%
  dplyr::filter(value, mpaa != "") %>%
  mutate(genre = genre %>%
           as_factor() %>%
           fct_infreq) %>%
  group_by(mpaa, genre) %>%
  summarize(n = n(), mean_budget = mean(budget, na.rm=T)) %>%
  ggplot(aes(x=mpaa, y=genre, fill = mean_budget)) +
    geom_tile()

```

```{r}

ggplot(movies, aes(x=rating)) +
  geom_histogram()

```

```{r}

movies %>% 
  pivot_longer(cols = c(Action, Animation, Comedy, Drama, Documentary, Romance, Short), names_to = "genre") %>%
  mutate(value = as.logical(value)) %>%
  dplyr::filter(value) %>%
  mutate(genre = genre %>%
           as_factor() %>%
           fct_infreq) %>%
  ggplot(aes(x=genre, y=rating)) +
    geom_boxplot()
  

```

(No maps, but maybe that's okay)
